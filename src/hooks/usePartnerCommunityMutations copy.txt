// src/hooks/usePartnerCommunityMutations.ts
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createSupabaseBrowserClient } from "@/lib/supabase/client";
import { toast } from "sonner";
import { useAuthStore } from "@/store/authStore";
import { type Community } from "@/lib/types";
import { type User } from "@supabase/supabase-js";

// Interfaces
interface CreateCommunityPayload {
  name: string;
  slug: string;
  description: string | null;
  stripe_price_id: string | null;
  imageFile: File;
}

interface UpdateCommunityPayload {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  stripe_price_id: string | null;
  imageFile?: File | null;
}

// NUEVA interface para el borrado
interface DeleteCommunityPayload {
  id: string;
}

// Funciones asíncronas
async function createCommunityFn(
  payload: CreateCommunityPayload,
  user: User
): Promise<void> {
  //if (!user) throw new Error("User not authenticated.");
  const supabase = createSupabaseBrowserClient();

  const { data: newCommunity, error: insertError } = await supabase
    .from("communities")
    .insert({
      name: payload.name,
      slug: payload.slug,
      description: payload.description,
      stripe_price_id: payload.stripe_price_id,
      status: "published",
      creator_id: user.id,
    })
    .select("id")
    .single();

  if (insertError) {
    if (insertError.message.includes("duplicate key value")) {
      throw new Error("The 'slug' is already in use. Please choose another.");
    }
    throw new Error(`Error creating community: ${insertError.message}`);
  }

  const fileExt = payload.imageFile.name.split(".").pop();
  const filePath = `${user.id}/${newCommunity.id}.${fileExt}`;

  const { error: uploadError } = await supabase.storage
    .from("community-images")
    .upload(filePath, payload.imageFile, { upsert: true });

  if (uploadError)
    throw new Error(`Error uploading image: ${uploadError.message}`);

  const { data: urlData } = supabase.storage
    .from("community-images")
    .getPublicUrl(filePath);

  const cacheBustedUrl = `${urlData.publicUrl}?t=${new Date().getTime()}`;

  await supabase
    .from("communities")
    .update({ image_url: cacheBustedUrl })
    .eq("id", newCommunity.id);
}

async function updateCommunityFn(
  payload: UpdateCommunityPayload,
  user: User
): Promise<void> {
  //if (!user) throw new Error("User not authenticated.");
  const supabase = createSupabaseBrowserClient();
  const { id, imageFile, ...textData } = payload;
  const dataToUpdate: Partial<Community> = { ...textData };

  if (imageFile) {
    const fileExt = imageFile.name.split(".").pop();
    const filePath = `${user.id}/${id}.${fileExt}`;

    const { error: uploadError } = await supabase.storage
      .from("community-images")
      .upload(filePath, imageFile, { upsert: true });

    if (uploadError)
      throw new Error(`Error uploading new image: ${uploadError.message}`);

    const { data: urlData } = supabase.storage
      .from("community-images")
      .getPublicUrl(filePath);
    dataToUpdate.image_url = `${urlData.publicUrl}?t=${new Date().getTime()}`;
  }

  const { error } = await supabase
    .from("communities")
    .update(dataToUpdate)
    .eq("id", id);
  if (error) {
    if (error.message.includes("duplicate key value")) {
      throw new Error("The 'slug' is already in use. Please choose another.");
    }
    throw new Error(`Error updating community: ${error.message}`);
  }
}

// NUEVA función asíncrona para borrar
async function deleteCommunityFn(
  payload: DeleteCommunityPayload
): Promise<void> {
  const supabase = createSupabaseBrowserClient();
  const { error } = await supabase.functions.invoke(
    "delete-partner-community",
    {
      body: { communityId: payload.id },
    }
  );

  if (error) {
    throw new Error(`Function error: ${error.message}`);
  }
}

export function usePartnerCommunityMutations() {
  const queryClient = useQueryClient();
  const { user } = useAuthStore();

  const { mutate: createCommunity, isPending: isCreatingCommunity } =
    useMutation({
      mutationFn: (payload: CreateCommunityPayload) =>
        createCommunityFn(payload, user),
      onSuccess: () => {
        toast.success("Community created successfully!");
        queryClient.invalidateQueries({
          queryKey: ["partner-communities", user?.id],
        });
        queryClient.invalidateQueries({
          queryKey: ["user-memberships", user?.id],
        });
      },
      onError: (error) => toast.error(error.message),
    });

  const { mutate: updateCommunity, isPending: isUpdatingCommunity } =
    useMutation({
      mutationFn: (payload: UpdateCommunityPayload) =>
        updateCommunityFn(payload, user),
      onSuccess: () => {
        toast.success("Community updated successfully!");
        queryClient.invalidateQueries({
          queryKey: ["partner-communities", user?.id],
        });
        queryClient.invalidateQueries({
          queryKey: ["user-memberships", user?.id],
        });
      },
      onError: (error) => toast.error(error.message),
    });

  // NUEVA mutación para borrar
  const { mutate: deleteCommunity, isPending: isDeletingCommunity } =
    useMutation({
      mutationFn: deleteCommunityFn,
      onSuccess: () => {
        toast.success("Community deleted successfully.");
        queryClient.invalidateQueries({
          queryKey: ["partner-communities", user?.id],
        });
        queryClient.invalidateQueries({
          queryKey: ["user-memberships", user?.id],
        });
      },
      onError: (error) => toast.error(error.message),
    });

  return {
    createCommunity,
    isCreatingCommunity,
    updateCommunity,
    isUpdatingCommunity,
    deleteCommunity, // <-- Exportamos la nueva función
    isDeletingCommunity, // <-- y su estado de carga
  };
}
